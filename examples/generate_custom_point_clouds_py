import numpy as np
import easypde

# Define a function, determining whether each point is in the domain.
def in_domain(points):
    return np.logical_and(
        np.logical_and(points[:, 0]<=1, points[:, 1]>=0),
        points[:, 0]>=points[:, 1])

# Way 1 to generate points: create a grid and remove points outside the domain
points = np.mgrid[0:1:20j, 0:1:20j].T.reshape([-1, 2])
points = points[points[:, 1]<=points[:, 0]]

# Way 2 to generate points: manually create boundary points and randomly create internal points
# boundary_points = []
# for t in np.linspace(0, 1, 19, endpoint=False):
#     boundary_points.append([t, 0])
#     boundary_points.append([1, t])
# for t in np.linspace(0, 1, int(19*np.sqrt(2)), endpoint=False):
#     boundary_points.append([1-t, 1-t]) 
# internal_points = np.random.rand(400, 2)
# internal_points = internal_points[in_domain(internal_points)]  # Delete points out domain
# points = np.concatenate([boundary_points, internal_points])  # Simply join them

# Way 3 to generate points: manually create boundary points and randomly create internal points and relax by force
# boundary_points = []
# for t in np.linspace(0, 1, 19, endpoint=False):
#     boundary_points.append([t, 0])
#     boundary_points.append([1, t])
# for t in np.linspace(0, 1, int(19*np.sqrt(2)), endpoint=False):
#     boundary_points.append([1-t, 1-t]) 
# internal_points = np.random.rand(400, 2)
# internal_points = internal_points[in_domain(internal_points)]  # Delete points out domain
# # Relax points
# points = easypde.pointcloud.relax_points(boundary_points, internal_points, 1 / 20)
# points = points[in_domain(points)]  # Delete points went out the domain.

# Way 4 to generate points: manually create boundary points and randomly create internal points and relax by Voronoi
# boundary_points = []
# for t in np.linspace(0, 1, 19, endpoint=False):
#     boundary_points.append([t, 0])
#     boundary_points.append([1, t])
# for t in np.linspace(0, 1, int(19*np.sqrt(2)), endpoint=False):
#     boundary_points.append([1-t, 1-t]) 
# internal_points = np.random.rand(400, 2)
# internal_points = internal_points[in_domain(internal_points)]  # Delete points out domain
# # Relax points
# points = easypde.pointcloud.relax_points_voronoi(boundary_points, internal_points, in_domain)

# Solve
A = np.zeros((len(points), len(points)))
b = np.zeros(len(points))
weight_distribution_radius = easypde.pointcloud.get_typical_distance(points)*0.1
for i, point in enumerate(points):
    x = point[0]
    y = point[1]
    if x == 1 or y == 0 or x == y:  # On boundary
        a = np.arctan2(x, y)
        easypde.edit_A_and_b(i, A, b, points, point, 5, [1, 0, 0, 0, 0, 0],
                             weight_distribution_radius=weight_distribution_radius)
    else:  # Internal
        easypde.edit_A_and_b(i, A, b, points, point, 16, [0, 0, 0, 1, 0, 1],
                             value=1,
                             weight_distribution_radius=weight_distribution_radius)
solution = np.linalg.solve(A, b)

# Visualize
easypde.plot_points(points, field=solution)
